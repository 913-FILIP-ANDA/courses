//
//  main.cpp
//  opencl
//
//  Created by Cosmin Rusu on 12/4/17.
//  Copyright © 2017 Duty Labs. All rights reserved.
//
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <opencv2/opencv.hpp>

// This include pulls in everything you need to develop with OpenCL in OS X.
#include <OpenCL/opencl.h>

// Include the header file generated by Xcode.  This header file contains the
//  kernel block declaration.
#include "image_filter.cl.h"

// Hard-coded number of values to test, for convenience.
#define NUM_VALUES 1024
#define MAXVALUE 100
#define EPS 0.00001

using namespace std;
using namespace cv;

int main (int argc, const char * argv[]) {
    srand(time(NULL));
    int i;
    char name[128];
    
    // First, try to obtain a dispatch queue that can send work to the
    // GPU in our system.
    dispatch_queue_t queue =
    gcl_create_dispatch_queue(CL_DEVICE_TYPE_GPU, NULL);
    
    // In the event that our system does NOT have an OpenCL-compatible GPU,
    // we can use the OpenCL CPU compute device instead.
    if (queue == NULL) {
        queue = gcl_create_dispatch_queue(CL_DEVICE_TYPE_CPU, NULL);
    }
    
    // This is not required, but let's print out the name of the device
    // we are using to do work.  We could use the same function,
    // clGetDeviceInfo, to obtain all manner of information about the device.
    cl_device_id gpu = gcl_get_device_id_with_dispatch_queue(queue);
    clGetDeviceInfo(gpu, CL_DEVICE_NAME, 128, name, NULL);
    fprintf(stdout, "Created a dispatch queue using the %s\n", name);
    
    // Reading the input data
    Mat image;
    image = imread("image.jpg", CV_LOAD_IMAGE_COLOR);
    if (!image.data) {
        printf("No image data\n");
        return -1;
    }
    
    Mat output(image.rows, image.cols, CV_8UC3, Scalar(0, 0, 0));
    
    // Once the computation using CL is done, will have to read the results
    // back into our application's memory space.  Allocate some space for that.
    uchar* test_out = output.data;
    
    // The test kernel takes two parameters: an input float array and an
    // output float array.  We can't send the application's buffers above, since
    // our CL device operates on its own memory space.  Therefore, we allocate
    // OpenCL memory for doing the work.  Notice that for the input array,
    // we specify CL_MEM_COPY_HOST_PTR and provide the fake input data we
    // created above.  This tells OpenCL to copy the data into its memory
    // space before it executes the kernel.
    void* mem_a  = gcl_malloc(sizeof(cl_uchar) * (image.rows * image.cols * 3), image.data,
                              CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    
    // The output array is not initalized; we're going to fill it up when
    // we execute our kernel.
    void* mem_out =
    gcl_malloc(sizeof(cl_uchar) * (image.rows * image.cols * 3), NULL, CL_MEM_WRITE_ONLY);
    
    // Dispatch the kernel block using one of the dispatch_ commands and the
    // queue created earlier.
    
    dispatch_sync(queue, ^{
        // Although we could pass NULL as the workgroup size, which would tell
        // OpenCL to pick the one it thinks is best, we can also ask
        // OpenCL for the suggested size, and pass it ourselves.
        size_t wgs;
        gcl_get_kernel_block_workgroup_info(image_filter_kernel,
                                            CL_KERNEL_WORK_GROUP_SIZE,
                                            sizeof(wgs), &wgs, NULL);
        
        // The N-Dimensional Range over which we'd like to execute our
        // kernel.  In this case, we're operating on a 1D buffer, so
        // it makes sense that the range is 1D.
        cl_ndrange range = {
            1,
            // The number of dimensions to use.
            
            {0, 0, 0},
            // The offset in each dimension.  To specify
            // that all the data is processed, this is 0
            // in the test case.
            
            {1024 * 1024 * 1024, 0, 0},
            // The global range—this is how many items
            // IN TOTAL in each dimension you want to
            // process.
            
            {wgs, 0, 0}
            // The local size of each workgroup.  This
            // determines the number of work items per
            // workgroup.  It indirectly affects the
            // number of workgroups, since the global
            // size / local size yields the number of
            // workgroups.  In this test case, there are
            // NUM_VALUE / wgs workgroups.
        };
        // Calling the kernel is easy; simply call it like a function,
        // passing the ndrange as the first parameter, followed by the expected
        // kernel parameters.  Note that we case the 'void*' here to the
        // expected OpenCL types
        
        image_filter_kernel(&range, (cl_uchar*)mem_a, (cl_uchar*)mem_out, (cl_int) image.rows * image.cols * 3);
        
        // Getting data out of the device's memory space is also easy;
        // use gcl_memcpy.  In this case, gcl_memcpy takes the output
        // computed by the kernel and copies it over to the
        // application's memory space.
        
        gcl_memcpy(test_out, mem_out, sizeof(cl_uchar) * (image.rows * image.cols * 3));
    });
    
    
    fprintf(stdout, "Done.\n");
    
    imwrite("grayscale.jpg", output);
    
    // Don't forget to free up the CL device's memory when you're done.
    gcl_free(mem_a);
    gcl_free(mem_out);
    
    // Finally, release your queue just as you would any GCD queue.
    dispatch_release(queue);
}
